
@Article{         10.1145/3571266,
  Author        = "Baumann, Pascal and Ganardi, Moses and Majumdar, Rupak and Thinniyam, Ramanathan S. and Zetzsche, Georg",
  Abstract      = "A fundamental problem in refinement verification is to check that the language of behaviors of an implementation is included in the language of the specification. We consider the refinement verification problem where the implementation is a multithreaded shared memory system modeled as a multistack pushdown automaton and the specification is an input-deterministic multistack pushdown language. Our main result shows that the context-bounded refinement problem, where we ask that all behaviors generated in runs of bounded number of context switches belong to a specification given by a Dyck language, is decidable and coNP-complete. The more general case of input-deterministic languages follows, with the same complexity. Context-bounding is essential since emptiness for multipushdown automata is already undecidable, and so is the refinement verification problem for the subclass of regular specifications. Input-deterministic languages capture many non-regular specifications of practical interest and our result opens the way for algorithmic analysis of these properties. The context-bounded refinement problem is coNP-hard already with deterministic regular specifications; our result demonstrates that the problem is not harder despite the stronger class of specifications. Our proof introduces several general techniques for formal languages and counter programs and shows that the search for counterexamples can be reduced in non-deterministic polynomial time to the satisfiability problem for existential Presburger arithmetic. These techniques are essential to ensure the coNP upper bound: existing techniques for regular specifications are not powerful enough for decidability, while simple reductions lead to problems that are either undecidable or have high complexities. As a special case, our decidability result gives an algorithmic verification technique to reason about reference counting and re-entrant locking in multithreaded programs.",
  Address       = "New York, NY, USA",
  articleno     = "73",
  date-added    = "2023-01-17 09:02:28 +0100",
  date-modified = "2023-01-17 09:02:28 +0100",
  DOI           = "10.1145/3571266",
  issue_date    = "January 2023",
  Journal       = "Proc. ACM Program. Lang.",
  Keywords      = "Dyck language, inclusion problem, multithreaded programs, computational complexity, context bounded, refinement verification",
  Month         = "jan",
  Number        = "POPL",
  numpages      = "30",
  Publisher     = "Association for Computing Machinery",
  Title         = "Context-Bounded Verification of Context-Free Specifications",
  URL           = "https://doi.org/10.1145/3571266",
  Volume        = "7",
  Year          = "2023",
  bdsk-url-1    = "https://doi.org/10.1145/3571266",
  File          = "Context-Bounded Verification of Context-Free Specifications - a.pdf"
}
