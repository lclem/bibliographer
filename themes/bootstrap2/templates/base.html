<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}{{ SITENAME }}{% endblock %}</title>

<!-- 	  script-src 'wasm-unsafe-eval' 'wasm-eval'; object-src 'none'; -->
    <meta http-equiv="content-security-policy" content=""/>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="{{ AUTHOR }}">
    <meta name="authors" content="{{ AUTHORS }}">
    <meta name="year" content="{{ YEAR }}">
    <meta name="bibfile" content="{{ BIBFILE }}">
    <meta name="pdffile" content="{{ PDFFILE }}">

    <!-- Le styles -->
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/stork-basic.css" />
    <!-- <link rel="stylesheet" href="https://files.stork-search.net/basic.css" /> -->

    <link href="{{ SITEURL }}/theme/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/font-awesome.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/pygments.css" rel="stylesheet">

    <!-- Le fav and touch icons -->
    <!-- <link rel="shortcut icon" href="{{ SITEURL }}/theme/images/favicon.ico">
    <link rel="apple-touch-icon" href="{{ SITEURL }}/theme/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="{{ SITEURL }}/theme/images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="{{ SITEURL }}/theme/images/apple-touch-icon-114x114.png"> -->

    <!-- <link href="{{ SITEURL }}/{{ FEED }}" type="application/atom+xml" rel="alternate" title="{{ SITENAME }} ATOM Feed" />
    {% if FEED_RSS %}
    <link href="{{ SITEURL }}/{{ FEED_RSS }}" type="application/atom+xml" rel="alternate" title="{{ SITENAME }} RSS Feed" />
    {% endif %} -->

  </head>

  <body id="drop-area">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="{{ SITEURL }}/index.html">{{ SITENAME }} {% if SITESUBTITLE %} <strong>{{ SITESUBTITLE }}</strong>{% endif %}</a>
          <div class="nav-collapse">
            <ul class="nav">
              {% for title, link in MENUITEMS %}
                <li><a href="{{ link }}">{{ title }}</a></li>
              {% endfor %}
              {% if DISPLAY_PAGES_ON_MENU %}
                {% for page in pages %}
                  <li><a href="{{ SITEURL }}/{{ page.url }}">{{ page.title }}</a></li>
                {% endfor %}
              <li class="divider-vertical"></li>
              {% endif %}
              {% if DISPLAY_CATEGORIES_ON_MENU %}
                {% for cat, null in categories %}
                  <li {% if cat == category %}class="active"{% endif %}>
                    <a href="{{ SITEURL }}/{{ cat.url }}">
                      <i class="icon-folder-open icon-large"></i>{{ cat }}
                    </a>
                  </li>
                {% endfor %}
              {% endif %}
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
          <div class="stork-wrapper">
            <p>
              <input id="stork-input" class="stork-input" data-stork="sitesearch" placeholder="Search publication"/>
              <button type="button" id="add-button" onclick="confirmBib()">Add reference</button>
            </p>
            <p>
              <div class="stork-output" data-stork="sitesearch-output"></div>
            </p>
          </div>
          {% block content %}
          {% endblock %}
          <p>
            <div class="small">
              Last Updated: {{ BUILD_TIME | strftime("%b %d, %Y, %H:%M:%S") }}
            </div>
            <div id="status" class = "small">
            </div>
          </p>      
        </div>
      </div>
  </div>
    <!-- Le javascript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="{{ SITEURL }}/theme/js/jquery-1.7.2.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bootstrap.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bibtexParse.js"></script>
    <script src="{{ SITEURL }}/theme/js/pdf.js"></script>
    <script>
      // https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/
			pdfjsLib.GlobalWorkerOptions.workerSrc = '{{ SITEURL }}/theme/js/pdf.worker.js';
		</script>

    <!-- <script src="https://mozilla.github.io/pdf.js/build/pdf.js"></script> 
    <script src="https://mozilla.github.io/pdf.js/build/pdf.worker.js"></script> -->

    <!-- <script src="https://files.stork-search.net/releases/v1.5.0/stork.js"></script> -->
    <script src="{{ SITEURL }}/theme/js/stork-1.6/stork.js"></script>

    <script>
        stork.initialize("{{ SITEURL }}/theme/js/stork-1.6/stork.wasm")
        options = {showScores: false};
        stork.register("sitesearch", "{{ SITEURL }}/search-index.st", options);
    </script>

    <script>
      let addButton = document.getElementById('add-button');
      var stork_input = document.getElementById('stork-input');
      let dropArea = document.getElementById('drop-area');
      let status = document.getElementById('status');
      let dt = [];
      let bibStr = "";

      var bibFile;

      function statusAppend(str) {
        console.log(str);
        status.innerText = str + "\n" + status.innerText;
      }

      // PDFJS.cMapUrl = "//mozilla/pdfjs-dist/tree/master/cmaps";
      // PDFJS.cMapPacked = true;

      stork_input.addEventListener("change", updateSearch, false);
      // stork_input.addEventListener("input", updateSearch, false);
      stork_input.addEventListener("paste", detectPaste, false);

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, preventDefaults, false)});
      ['dragenter', 'dragover'].forEach(eventName => {dropArea.addEventListener(eventName, highlight, false)});
      ['dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, unhighlight, false)});
      dropArea.addEventListener('drop', handleDrop, false)

      const target = document.querySelector("div.target");

      function preventDefaults (e) {
        e.preventDefault()
        e.stopPropagation()
      }

      function highlight(e) {
        dropArea.classList.add('highlight')
      }

      function unhighlight(e) {
        dropArea.classList.remove('highlight')
      }

      function handleDrop(e) {
        dt = e.dataTransfer;
        var len = dt.files.length;

        if (len != 1) {
          console.log("not supported: dropped files #" + len);
          return;
        }

        var theFile = dt.files[0];
        var fileName = theFile.name;

        if (fileName.endsWith(".bib") || fileName.endsWith(".txt")) {
          uploadBib(dt);
        }
        else if (fileName.endsWith(".pdf")) {
          uploadPdf(theFile);
        }
        else {
          console.log("unsupported format: " + fileName);
        }
      }

      const copyBib = async () => {
        try {
          let text = document.getElementById('bib').innerHTML;
          await navigator.clipboard.writeText(text);

          // var tooltip = document.getElementById("myTooltip");
          // tooltip.innerHTML = "copied to clipboard!";
          console.log('Content copied to clipboard');
        } catch (err) {
          // tooltip.innerHTML = "error: "+ err;
          console.error('Failed to copy: ', err);
        }
      }

      function triggerStorkSearch(str) {
        console.log('triggerStorkSearch: ' + str);
        stork_input.value = str;
        stork_input.dispatchEvent(new Event('input', { bubbles: true }));
      }

      function outFunc() {
        var tooltip = document.getElementById("myTooltip");
        tooltip.innerHTML = "Copy to clipboard";
      }

      function confirmBib() {
        uploadBib(dt, true);
      }

        // TODO: improve
        function sanitiseKey(key) {
          key = key.replace("/", "_");
          key = key.replace(":", "_");
      }

      async function openGitHub(key, fileName, bibStr) {

        sanitisedKey = sanitiseKey(key);

        url = "https://github.com/lclem/bibliographer/new/main/library/entries/";
        url += sanitisedKey + "?filename=" + fileName + "&value=";
        url += encodeURIComponent(bibStr);

        // create filename from key if not present
        if (fileName == "") {
          fileName = sanitisedKey + ".bib";
        }

        console.log("openGitHub, key:" + key + ", fileName: " + fileName + ", bibStr: " + bibStr);

        window.open(url, "_blank");
        addButton.style.display = "none";

      }

      const lowerize = obj =>
        Object.keys(obj).reduce((acc, k) => {
          acc[k.toLowerCase()] = obj[k];
          return acc;
        }, {});
        
      // TODO: when pasting a bib which gives a search hit, it is not possible to import: check what happens

      async function processBib(aBibStr, fileName, force = false) {

        bibStr = aBibStr.trim();
        console.log("processBib: " + bibStr);
        statusAppend("processing bib: " + bibStr);

        try {
          bibJSONs = bibtexParse.toJSON(bibStr);

          for (bibJSON of bibJSONs) {
            console.log(bibJSON);

            key = bibJSON["citationkey"];
            console.log("key: " + key);

            bibJSON.entryTags = lowerize[bibJSON.entryTags]
            tags = bibJSON.entryTags

            if ("title" in tags) {
              title = tags["title"];
            }
            else {
              title = ""
            }

            console.log("title: " + title);

      	    searchString = title; //key + " " + title;
            searchResults = stork.search("sitesearch", searchString);

            if (!force && (searchResults.total_hit_count > 0 && searchResults.results[0].score > 2000)) {
              console.log("bib already exists");

              stork.search("sitesearch", searchString);
              // triggerStorkSearch(str);
              addButton.style.display = "block";

            }
            else {

              // date-added    = "2018-12-22 10:50:04 +0100",
              var currentdate = new Date(); 
              var datetime =
                currentdate.getFullYear() + "-" +
                (currentdate.getMonth()+1) + "-" +
                currentdate.getDate() + " " +
                currentdate.getHours() + ":" +
                currentdate.getMinutes() + ":" +
                currentdate.getSeconds() +
                " +0100";

              bibJSON.entryTags["date-added"] = datetime;
              console.log(datetime);
              
              bibStr = bibtexParse.toBibtex([bibJSON], false);
              bibStr = bibStr.trim();
              console.log(bibStr);

              //TODO: at this stage from time to time the key could be garbage
              // and also the filename
              //sanitise it, eg. remove https:// etc

              openGitHub(key, fileName, bibStr);
            }
          }
        } catch (err) {
          console.error('Failed to parse bib: ', err);
        }
      }

      async function uploadBib(inp, force = false) {
        console.log("uploadBib: " + inp + ", force: " + force);

        if (force) {
          processBib(bibStr, "", force);
        }
        else {
          bibFile = inp.files[0];

          let fileName = "";
          
          var reader = new FileReader();
          reader.readAsText(bibFile, "UTF-8");
          reader.onload = function (evt) {
            bibStr = evt.target.result;

            if (bibFile.name !== null) {
              fileName = bibFile.name;
            }
            
            console.log("File name: " + fileName);

            processBib(bibStr, fileName, force);

          }
          reader.onerror = function (evt) {
            console.log("error reading file");
          }
        }
      }

      function getXmlHttp() {
        var xmlhttp;
        if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
            xmlhttp=new XMLHttpRequest();
        }
        else {// code for IE6, IE5
            xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
        }
        return xmlhttp;
      }

      // given a url fetch its contents and invoke the callback function on the result
      async function getWebPage(theUrl, callback) {

        statusAppend("getting url: " + theUrl);

        xmlhttp = getXmlHttp();
        xmlhttp.onreadystatechange = async function() {
          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            let res = xmlhttp.responseText;
            console.log("res: " + res);
            callback(res);
          }
          else {
            statusAppend("status: " + xmlhttp.status);
          }
        }

        try {
          xmlhttp.open("GET", theUrl, false);
          xmlhttp.send();
        } catch (err) {
          statusAppend('GET error: ', err);
        }

      }

      // get bib information given the doi
      async function doi2bib(doiUrl, callback) {

        statusAppend("doi: " + doiUrl);

        xmlhttp = getXmlHttp();
        xmlhttp.onreadystatechange = async function() {
          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            let res = xmlhttp.responseText;
            console.log("doi2bib: " + res);
            callback(res);
          }
        }

        xmlhttp.open("GET", doiUrl, false);
        xmlhttp.setRequestHeader('Accept', 'application/x-bibtex; charset=utf-8');
        // xmlhttp.setRequestHeader('Access-Control-Allow-Origin', '');
        xmlhttp.send();
        
      }

      // can get the PDF with https://sci-hub.se/
      // look for a url of the form https://moscow.sci-hub.se/864/d09cfcb7e8c9636cb503218595308a11/lasota2006.pdf#navpanes=0&view=FitH

      async function getBib(articleUrl) {

          articleUrl = articleUrl.trim();

          // detect arxiv link
	        // TODO: handle also https://arxiv.org/abs/math/0703211
          // TODO: handle also https://arxiv.org/pdf/2310.02393.pdf
          if (articleUrl.startsWith("https://arxiv.org/abs/")) {

            var split = articleUrl.split("/");
            var id = split.slice(-1)[0];

            console.log("arxiv id: " + id);

            // https://arxiv.org/abs/2104.14624
            // https://arxiv.org/pdf/2104.14624.pdf
            // https://ui.adsabs.harvard.edu/abs/2021arXiv210414624G/exportcitation

            year = "20" + id.substring(0, 2);
            // theUrl = "https://ui.adsabs.harvard.edu/abs/" + year + "arXiv" + id.replace(".", "") + "G" + "/exportcitation"
            theUrl = "https://ui.adsabs.harvard.edu/abs/arXiv:" + id + "/exportcitation";
            getWebPage(theUrl, res => {
              var el = document.createElement('html');
              el.innerHTML = res;

              var els = el.getElementsByClassName('export-textarea');
              var bibStr = els[0].innerText;

              fileName = id + ".bib";
              processBib(bibStr, fileName);

            });

          }
          // https://www.sciencedirect.com/science/article/pii/S0304397506001964
          else if (articleUrl.startsWith("https://www.sciencedirect.com/science/article/pii/")) {

            statusAppend("detected sciencedirect article");

            getWebPage(articleUrl, res => {
              var el = document.createElement('html');
              el.innerHTML = res;

              var els = el.getElementsByClassName('doi');
              var doi = els[0].innerText;

              doi2bib(doi, bibStr => { processBib(bibStr, ""); });

            });

          }
          // https://dl.acm.org/doi/10.1145/3087604.3087623
          // https://dl.acm.org/doi/abs/10.1145/1113439.1113446
          else if (articleUrl.startsWith("https://dl.acm.org/doi/")) {

            // get last two blocks when splitting by "/"
            var split = articleUrl.split("/");
            var slice = split.slice(-2);
            var doi = slice[0] + "/" + slice[1];
            var doiUrl = "https://doi.org/" + doi;

            doi2bib(doiUrl, bibStr => { processBib(bibStr, ""); });

          }
          // https://epubs.siam.org/doi/abs/10.1137/S0097539793251219
          // https://epubs.siam.org/action/downloadCitation?format=bibtex&include=abs&direct=true&doi=10.1137/S0097539793251219&downloadFileName=siam_S0097539793251219
          else if (articleUrl.startsWith("https://epubs.siam.org/doi/abs/")) {

          }
          // https://inria.hal.science/hal-02885579
          // https://inria.hal.science/hal-02885579/bibtex
          // https://pastel.hal.science/tel-01223284v2
          
          else if (articleUrl.startsWith("https://inria.hal.science/") ||
            articleUrl.startsWith("https://pastel.hal.science/") ||
            articleUrl.startsWith("https://hal.science/")) {

            var halId = "";

            if (articleUrl.includes("hal-")) {
              halId = "hal-" + articleUrl.split("hal-")[1];
            }
            else if (articleUrl.includes("tel-")) {
              halId = "tel-" + articleUrl.split("tel-")[1];
            }

            statusAppend("hal id: " + halId);

            var bibUrl = "https://inria.hal.science/" + halId + "/bibtex";
            getWebPage(bibUrl, bibStr => {
              
              var fileName = halId + ".bib";
              processBib(bibStr, fileName);

            });
            
          }
          // https://link.springer.com/chapter/10.1007/3-540-60915-6_4
          // https://link.springer.com/article/10.1007/s10883-019-09441-w
          else if (articleUrl.startsWith("https://link.springer.com/article/") ||
                  articleUrl.startsWith("https://link.springer.com/chapter/")) {

            statusAppend("detected springer article");

            var sciHubUrl = "https://sci-hub.se/";
            articleUrl = sciHubUrl + articleUrl;

            getWebPage(articleUrl, res => {
              var el = new DOMParser().parseFromString(res, "text/html");
              
              // var els = el.getElementsByClassName('c-bibliographic-information__value');
              var div = el.getElementById("doi");
              var doi = div.innerText.trim();
              var doiUrl = "https://doi.org/" + doi;

              doi2bib(doiUrl, bibStr => { processBib(bibStr, ""); });

            });  
            
          }
          // https://doi.org/10.1007/s10883-019-09441-w
          // dx.doi.org/10.2140/obs.2019.2.119
          else if (articleUrl.includes("doi.org")) {

            if (!articleUrl.startsWith("https://")) {
              articleUrl = "https://" + articleUrl;
            }

            // var strippedUrl = articleUrl.substring(8, articleUrl.length);
            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });
          }
          else {
            statusAppend("URL not recognised: " + articleUrl);
          }
      }

      async function updateSearch() {
        console.log("stork update search: " + stork_input.value);
        getBib(stork_input.value);
      }

      async function uploadPdf(thePdf) {

        console.log(thePdf);
        var fileName = thePdf.name;

        // match 2304.14575 inside the filename
        var rx = /[0-9][0-9][0-9][0-9]\.[0-9][0-9][0-9][0-9][0-9]/g;
        var matches = rx.exec(fileName);
        var arxivId = "";

        if (matches !== null && matches.length > 0) {
          arxivId = matches[0];
          console.log("arxiv id: " + arxivId);
        }
        else {
          console.log("cannot extract arxiv id");
        }

        var data = await thePdf.arrayBuffer();
        // console.log(data.byteLength);
        // console.log(data);

        var title = "";
        var author = "";

        await pdfjsLib.getDocument(data).promise.then(async doc => { 
          // console.log(doc);

          doc.getMarkInfo().then(info => console.log("mark info: " + info));
          doc.getDownloadInfo().then(info => console.log("download info: " + info));
          doc.getFieldObjects().then(info => console.log("field objs: " + info));
          doc.getAttachments().then(info => console.log("attachments: " + info));
          doc.getOutline().then(info => console.log("outline: " + info));
          doc.getPage(1).then(firstPage => {
            console.log("first page: " + firstPage);
            firstPage.getTextContent({ normalizeWhitespace: true }).then(content => {
              console.log("content: " + content);
            });
          });

          var meta = doc.getMetadata();
          meta.then(metadata => {
            
            console.log(metadata);

            var info = metadata.info;
            console.log(info);

            var meta = metadata.metadata;
            console.log(meta);

            author = info.Author;
            title = info.Title;
            creator = info.Creator;

            console.log("author: " + author);
            console.log("title: " + title);

            // sometimes the title contains an arxiv id
            // arXiv:2210.16580v1  [cs.DB]  29 Oct 2022
            if (title.startsWith("arXiv:")) {
              arxivId = title.split(":")[1].split(" ")[0].split("v")[0];
              console.log("extracted arxiv id from title: " + arxivId);
            }
            else if (title != "") {
              triggerStorkSearch(title);
            }

            // we have an arxiv PDF
            if (arxivId != "") {
              getBib("https://arxiv.org/abs/" + arxivId);
            }
            // we have an HAL PDF
            else if (creator == "HAL") {

            }

          });

        });        
      }

      function detectPaste(event) {
        // event.preventDefault();
        let paste = (event.clipboardData || window.clipboardData).getData("text");
        processBib(paste, "");
      };
    </script>
  </body>
</html>
