<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}{{ SITENAME }}{% endblock %}</title>

<!-- 	  script-src 'wasm-unsafe-eval' 'wasm-eval'; object-src 'none'; -->
    <meta http-equiv="content-security-policy" content=""/>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="{{ AUTHOR }}">
    <meta name="authors" content="{{ AUTHORS }}">
    <meta name="year" content="{{ YEAR }}">
    <meta name="bibfile" content="{{ BIBFILE }}">
    <meta name="pdffile" content="{{ PDFFILE }}">

    <!-- Le styles -->
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/stork-basic.css" />
    <!-- <link rel="stylesheet" href="https://files.stork-search.net/basic.css" /> -->

    <link href="{{ SITEURL }}/theme/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/font-awesome.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/pygments.css" rel="stylesheet">

    <!-- Le fav and touch icons -->
    <!-- <link rel="shortcut icon" href="{{ SITEURL }}/theme/images/favicon.ico">
    <link rel="apple-touch-icon" href="{{ SITEURL }}/theme/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="{{ SITEURL }}/theme/images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="{{ SITEURL }}/theme/images/apple-touch-icon-114x114.png"> -->

    <!-- <link href="{{ SITEURL }}/{{ FEED }}" type="application/atom+xml" rel="alternate" title="{{ SITENAME }} ATOM Feed" />
    {% if FEED_RSS %}
    <link href="{{ SITEURL }}/{{ FEED_RSS }}" type="application/atom+xml" rel="alternate" title="{{ SITENAME }} RSS Feed" />
    {% endif %} -->

  </head>

  <body id="drop-area">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="{{ SITEURL }}/index.html">{{ SITENAME }} {% if SITESUBTITLE %} <strong>{{ SITESUBTITLE }}</strong>{% endif %}</a>
          <div class="nav-collapse">
            <ul class="nav">
              {% for title, link in MENUITEMS %}
                <li><a href="{{ link }}">{{ title }}</a></li>
              {% endfor %}
              {% if DISPLAY_PAGES_ON_MENU %}
                {% for page in pages %}
                  <li><a href="{{ SITEURL }}/{{ page.url }}">{{ page.title }}</a></li>
                {% endfor %}
              <li class="divider-vertical"></li>
              {% endif %}
              {% if DISPLAY_CATEGORIES_ON_MENU %}
                {% for cat, null in categories %}
                  <li {% if cat == category %}class="active"{% endif %}>
                    <a href="{{ SITEURL }}/{{ cat.url }}">
                      <i class="icon-folder-open icon-large"></i>{{ cat }}
                    </a>
                  </li>
                {% endfor %}
              {% endif %}
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
          <div class="stork-wrapper">
            <p>
              <input id="stork-input" class="stork-input" data-stork="sitesearch" placeholder="Search publication"/>
              <button type="button" id="add-button" onclick="confirmBib()">Add reference</button>
            </p>
            <p>
              <div class="stork-output" data-stork="sitesearch-output"></div>
            </p>
          </div>
          {% block content %}
          {% endblock %}
          <p>
            <div class="small">
              Last Updated: {{ BUILD_TIME | strftime("%b %d, %Y, %H:%M:%S") }}
            </div>
            <div id="status" class = "small">
            </div>
          </p>      
        </div>
      </div>
  </div>
    <!-- Le javascript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="{{ SITEURL }}/theme/js/jquery-1.7.2.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bootstrap.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bibtexParse.js"></script>
    <script src="{{ SITEURL }}/theme/js/pdf.js"></script>
    <script>
      // https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/
			pdfjsLib.GlobalWorkerOptions.workerSrc = '{{ SITEURL }}/theme/js/pdf.worker.js';
		</script>

    <script type="module">
      import { Octokit } from "https://esm.sh/@octokit/rest";
      var pat = "g i t h u b _ p a t _ 1 1 A B C B U P Q 0 l w 1 1 T Z q z c J j B _ p K S o S y i I R 9 X d Q A m 1 l L 4 Q n Z E 0 b 6 J y 0 b Q g q E F 8 V W 9 R o T n 5 B V Z N 3 H X Z c B h f o g F"
      pat = pat.replaceAll(" ", "");
      const octokit = new Octokit({ auth: pat });
      window.octokit = octokit;
      console.log("Octokit loaded");
    </script>

    <!-- <script src="https://mozilla.github.io/pdf.js/build/pdf.js"></script> 
    <script src="https://mozilla.github.io/pdf.js/build/pdf.worker.js"></script> -->

    <script>
      let addButton = document.getElementById('add-button');
      var stork_input = document.getElementById('stork-input');
      let dropArea = document.getElementById('drop-area');
      let status = document.getElementById('status');
      let dt = [];
      let bibStr = "";

      var bibFile;

      function statusAppend(str) {
        console.log(str);
        status.innerText = str + "\n" + status.innerText;
      }

      // PDFJS.cMapUrl = "//mozilla/pdfjs-dist/tree/master/cmaps";
      // PDFJS.cMapPacked = true;

      stork_input.addEventListener("change", updateSearch, false);
      // stork_input.addEventListener("input", updateSearch, false);
      stork_input.addEventListener("paste", detectPaste, false);

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, preventDefaults, false)});
      ['dragenter', 'dragover'].forEach(eventName => {dropArea.addEventListener(eventName, highlight, false)});
      ['dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, unhighlight, false)});
      dropArea.addEventListener('drop', handleDrop, false)

      const target = document.querySelector("div.target");

      function preventDefaults (e) {
        e.preventDefault()
        e.stopPropagation()
      }

      function highlight(e) {
        dropArea.classList.add('highlight')
      }

      function unhighlight(e) {
        dropArea.classList.remove('highlight')
      }

      function handleDrop(e) {
        dt = e.dataTransfer;
        var len = dt.files.length;

        if (len != 1) {
          console.log("not supported: dropped files #" + len);
          return;
        }

        var theFile = dt.files[0];
        var fileName = theFile.name;

        if (fileName.endsWith(".bib") || fileName.endsWith(".txt")) {
          uploadBib(dt);
        }
        else if (fileName.endsWith(".pdf")) {
          uploadPdf(theFile);
        }
        else {
          console.log("unsupported format: " + fileName);
        }
      }

      const copyBib = async () => {
        try {
          let text = document.getElementById('bib').innerHTML;
          await navigator.clipboard.writeText(text);

          // var tooltip = document.getElementById("myTooltip");
          // tooltip.innerHTML = "copied to clipboard!";
          console.log('Content copied to clipboard');
        } catch (err) {
          // tooltip.innerHTML = "error: "+ err;
          console.error('Failed to copy: ', err);
        }
      }

      function triggerStorkSearch(str) {
        console.log('triggerStorkSearch: ' + str);
        stork_input.value = str;
        stork_input.dispatchEvent(new Event('input', { bubbles: true }));
      }

      function outFunc() {
        var tooltip = document.getElementById("myTooltip");
        tooltip.innerHTML = "Copy to clipboard";
      }

      function confirmBib() {
        uploadBib(dt, true);
      }

        // TODO: improve
        function sanitiseKey(key) {

          newKey = key.replaceAll("/", "_");
          newKey = newKey.replaceAll(":", "_");
          console.log("sanitising key " + key + " --> " + newKey);

          return newKey;
      }

      async function openGitHub(key, fileName, bibStr) {

        sanitisedKey = sanitiseKey(key);
        
        // create filename from key if not present
        if (fileName == "") {
          fileName = sanitisedKey + ".bib";
        }

        url = "https://github.com/lclem/bibliographer/new/main/library/entries/";
        url += sanitisedKey + "?filename=" + fileName + "&value=";
        url += encodeURIComponent(bibStr);

        console.log("openGitHub, key:" + sanitisedKey + ", fileName: " + fileName + ", bibStr: " + bibStr + " = " + url);

        window.open(url, "_blank");
        addButton.style.display = "none";
      }

      const lowerize = obj =>
        Object.keys(obj).reduce((acc, k) => {
          acc[k.toLowerCase()] = obj[k];
          return acc;
        }, {});
        
      // TODO: when pasting a bib which gives a search hit, it is not possible to import: check what happens

      async function processBib(aBibStr, fileName, force = false) {

        bibStr = aBibStr.trim();
        console.log("processBib: " + bibStr);
        statusAppend("processing bib: " + bibStr);

        try {
          bibJSONs = bibtexParse.toJSON(bibStr);
          // console.log(bibJSONs);

          for (bibJSON of bibJSONs) {
            console.log(bibJSON);

            key = bibJSON.citationKey;
            console.log("key: " + key);

            sanitisedKey = sanitiseKey(key);
            bibJSON.citationKey = sanitisedKey;

            bibJSON.entryTags = lowerize(bibJSON.entryTags);
            tags = bibJSON.entryTags;
            // tags = lowerize(bibJSON.entryTags);
            console.log("tags: " + JSON.stringify(tags));

            if ("title" in tags) {
              title = tags["title"];
            }
            else {
              title = "";
            }

            console.log("title: " + title);

      	    searchString = title; //key + " " + title;
            searchResults = stork.search("sitesearch", searchString);

            if (!force && (searchResults.total_hit_count > 0 && searchResults.results[0].score > 2000)) {
              console.log("bib already exists: " + searchResults.total_hit_count);
              console.log("results: ");
              console.log(searchResults.results)

              stork.search("sitesearch", searchString);
              // triggerStorkSearch(str);
              addButton.style.display = "block";

            }
            else {

              // date-added    = "2018-12-22 10:50:04 +0100",
              var currentdate = new Date(); 
              var datetime =
                currentdate.getFullYear() + "-" +
                (currentdate.getMonth()+1) + "-" +
                currentdate.getDate() + " " +
                currentdate.getHours() + ":" +
                currentdate.getMinutes() + ":" +
                currentdate.getSeconds() +
                " +0100";

              bibJSON.entryTags["date-added"] = datetime;
              console.log(datetime);
              
              bibStr = bibtexParse.toBibtex([bibJSON], false);
              bibStr = bibStr.trim();
              console.log(bibStr);

              //TODO: at this stage from time to time the key could be garbage
              // and also the filename
              //sanitise it, eg. remove https:// etc              

              openGitHub(key, fileName, bibStr);
            }
          }
        } catch (err) {
          console.error('Failed to parse bib: ', err);
        }
      }

      async function uploadBib(inp, force = false) {
        console.log("uploadBib: " + inp + ", force: " + force);

        if (force) {
          processBib(bibStr, "", force);
        }
        else {
          bibFile = inp.files[0];

          let fileName = "";
          
          var reader = new FileReader();
          reader.readAsText(bibFile, "UTF-8");
          reader.onload = function (evt) {
            bibStr = evt.target.result;

            if (bibFile.name !== null) {
              fileName = bibFile.name;
            }
            
            console.log("File name: " + fileName);
            processBib(bibStr, fileName, force);

          }
          reader.onerror = function (evt) {
            console.log("error reading file");
          }
        }
      }

      function getXmlHttp() {
        var xmlhttp;
        if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
            xmlhttp=new XMLHttpRequest();
        }
        else {// code for IE6, IE5
            xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
        }
        return xmlhttp;
      }

      // given a url fetch its contents and invoke the callback function on the result
      async function getWebPage(theUrl, callback) {

        statusAppend("getting url: " + theUrl);

        xmlhttp = getXmlHttp();
        xmlhttp.onreadystatechange = async function() {
          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            let res = xmlhttp.responseText;
            console.log("res: " + res);
            callback(res);
          }
          else {
            statusAppend("status: " + xmlhttp.status);
          }
        }

        try {
          xmlhttp.open("GET", theUrl, false);
          xmlhttp.send();
        } catch (err) {
          statusAppend('GET error: ', err);
        }

      }

      // get bib information given the doi
      async function doi2bib(doiUrl, callback) {

        statusAppend("doi: " + doiUrl);

        xmlhttp = getXmlHttp();
        xmlhttp.onreadystatechange = async function() {
          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            let res = xmlhttp.responseText;
            console.log("doi2bib: " + res);
            callback(res);
          }
        }

        xmlhttp.open("GET", doiUrl, false);
        xmlhttp.setRequestHeader('Accept', 'application/x-bibtex; charset=utf-8');
        // xmlhttp.setRequestHeader('Access-Control-Allow-Origin', '');
        xmlhttp.send();
        
      }

      function isDoi(str) {
          var rx = /^10\.[0-9][0-9][0-9][0-9][0-9]*\//;
          var matches = rx.exec(str);
          return matches !== null && matches.length > 0;
      }

      // can get the PDF with https://sci-hub.se/
      // look for a url of the form https://moscow.sci-hub.se/864/d09cfcb7e8c9636cb503218595308a11/lasota2006.pdf#navpanes=0&view=FitH

      async function getBib(articleUrl) {

          articleUrl = articleUrl.trim();

          // detect arxiv link
	        // TODO: handle also https://arxiv.org/abs/math/0703211
          // TODO: handle also https://arxiv.org/pdf/2310.02393.pdf
          // TODO: handle also https://aps.arxiv.org/abs/2307.07460
          if (articleUrl.startsWith("https://arxiv.org/abs/")) {

            var split = articleUrl.split("/");
            var id = split.slice(-1)[0];

            console.log("arxiv id: " + id);

            // https://arxiv.org/abs/2104.14624
            // https://arxiv.org/pdf/2104.14624.pdf
            // https://ui.adsabs.harvard.edu/abs/2021arXiv210414624G/exportcitation

            year = "20" + id.substring(0, 2);
            // theUrl = "https://ui.adsabs.harvard.edu/abs/" + year + "arXiv" + id.replace(".", "") + "G" + "/exportcitation"
            theUrl = "https://ui.adsabs.harvard.edu/abs/arXiv:" + id + "/exportcitation";
            getWebPage(theUrl, res => {
              var el = document.createElement('html');
              el.innerHTML = res;

              var els = el.getElementsByClassName('export-textarea');
              var bibStr = els[0].innerText;

              fileName = id + ".bib";
              processBib(bibStr, fileName);

            });

          }
          // https://www.sciencedirect.com/science/article/pii/S0304397506001964
          else if (articleUrl.startsWith("https://www.sciencedirect.com/science/article/pii/")) {

            statusAppend("detected sciencedirect article");

            getWebPage(articleUrl, res => {
              var el = document.createElement('html');
              el.innerHTML = res;

              var els = el.getElementsByClassName('doi');
              var doi = els[0].innerText;

              doi2bib(doi, bibStr => { processBib(bibStr, ""); });

            });

          }
          // https://dl.acm.org/doi/10.1145/3087604.3087623
          // https://dl.acm.org/doi/abs/10.1145/1113439.1113446
          else if (articleUrl.startsWith("https://dl.acm.org/doi/")) {

            // get last two blocks when splitting by "/"
            var split = articleUrl.split("/");
            var slice = split.slice(-2);
            var doi = slice[0] + "/" + slice[1];
            var doiUrl = "https://doi.org/" + doi;

            doi2bib(doiUrl, bibStr => { processBib(bibStr, ""); });

          }
          // https://epubs.siam.org/doi/abs/10.1137/S0097539793251219
          // https://epubs.siam.org/action/downloadCitation?format=bibtex&include=abs&direct=true&doi=10.1137/S0097539793251219&downloadFileName=siam_S0097539793251219
          else if (articleUrl.startsWith("https://epubs.siam.org/doi/abs/")) {

          }
          // https://inria.hal.science/hal-02885579
          // https://inria.hal.science/hal-02885579/bibtex
          // https://pastel.hal.science/tel-01223284v2
          // https://hal.archives-ouvertes.fr/hal-03466451
          
          else if (articleUrl.startsWith("https://inria.hal.science/") ||
            articleUrl.startsWith("https://pastel.hal.science/") ||
            articleUrl.startsWith("https://hal.science/") ||
            articleUrl.startsWith("https://hal.archives-ouvertes.fr/")) {

            var halId = "";

            if (articleUrl.includes("hal-")) {
              halId = "hal-" + articleUrl.split("hal-")[1];
            }
            else if (articleUrl.includes("tel-")) {
              halId = "tel-" + articleUrl.split("tel-")[1];
            }

            statusAppend("hal id: " + halId);

            var bibUrl = "https://inria.hal.science/" + halId + "/bibtex";
            getWebPage(bibUrl, bibStr => {
              
              var fileName = halId + ".bib";
              processBib(bibStr, fileName);

            });
            
          }
          // https://link.springer.com/chapter/10.1007/3-540-60915-6_4
          // https://link.springer.com/article/10.1007/s10883-019-09441-w
          // https://link.springer.com/chapter/10.1007/978-3-030-72016-2_16
          else if (articleUrl.startsWith("https://link.springer.com/article/") ||
                  articleUrl.startsWith("https://link.springer.com/chapter/")) {

            doi = articleUrl.split("/").slice(-2).join("/");
            statusAppend("detected springer article, doi: " + doi);

            articleUrl = "https://doi.org/" + doi;
            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });

            // does not always return a doi
            // var sciHubUrl = "https://sci-hub.se/";
            // articleUrl = sciHubUrl + articleUrl;

            // getWebPage(articleUrl, res => {
            //   var el = new DOMParser().parseFromString(res, "text/html");
              
            //   // var els = el.getElementsByClassName('c-bibliographic-information__value');
            //   var div = el.getElementById("doi");
            //   var doi = div.innerText.trim();
            //   var doiUrl = "https://doi.org/" + doi;

            //   doi2bib(doiUrl, bibStr => { processBib(bibStr, ""); });

            // });
            
          }
          // https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2023.31
          else if (articleUrl.startsWith("https://drops.dagstuhl.de/entities/document/")) {

            // get the doi
            doi = articleUrl.split("/").slice(-2).join("/");
            statusAppend("detected LIPIcs dagstuhl drops article, doi: " + doi);

            articleUrl = "https://doi.org/" + doi;
            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });

          }
          // https://doi.org/10.1007/s10883-019-09441-w
          // dx.doi.org/10.2140/obs.2019.2.119
          // TODO: recognise a doi also without the URL prefix, i.e., just "10.1007/s10883-019-09441-w"
          else if (articleUrl.includes("doi.org")) {

            if (!articleUrl.startsWith("https://")) {
              articleUrl = "https://" + articleUrl;
            }

            // var strippedUrl = articleUrl.substring(8, articleUrl.length);
            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });
          }
          else if (isDoi(articleUrl)) {
            console.log("naked doi detected: " + articleUrl);
            articleUrl = "https://doi.org/" + articleUrl;
            doi2bib(articleUrl, bibStr => { processBib(bibStr, ""); });
          }
          else {
            statusAppend("URL not recognised: " + articleUrl);
          }
      }

      async function updateSearch() {
        console.log("stork update search: " + stork_input.value);
        getBib(stork_input.value);
      }

      const toBase64 = file => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
      });

      // TODO: if we are creating a new bib entry,
      // then also automatically add the dropped pdf to the corresponding git folder

      async function uploadPdf(thePdf) {

        console.log(thePdf);
        var fileName = thePdf.name;

        // if we are on an article page,
        // dropping a PDF means "add this PDF to this entry"
        if(document.getElementById('title_label') != null){ // && document.getElementById('PDF_label') == null) {

          const articleUrl = document.getElementById('article_url');
          console.log("PDF dropped on article page, url: " + articleUrl);

          pdfContents = await toBase64(thePdf);
          pdfContents = pdfContents.slice(pdfContents.indexOf(",") + 1);
          // console.log("pdfContents: " + pdfContents);

          var rootFolder = document.getElementById('article_rootfolder').getAttribute("href");
          console.log("rootFolder: " + rootFolder);
          path = "library/entries/" + rootFolder.split("/").slice(-1) + "/";

          fileName = encodeURIComponent(fileName);
          putRequest = 'PUT /repos/lclem/bibliographer/contents/' + path + fileName;
          statusAppend("put request: " + putRequest);

          const result = await octokit.request(putRequest, {
            accept: 'application/vnd.github+json',
            owner: 'lclem',
            repo: 'bibliographer',
            path: fileName,
            message: 'PDF upload',
            // sha: '0d5a690c8fad5e605a6e8766295d9d459d65de42',
            committer: {
              name: 'Lorenzo C',
              email: 'clementelorenzo@gmail.com'
            },
            content: pdfContents,
            headers: {
              'X-GitHub-Api-Version': '2022-11-28'
            }
          });

          console.log(result.data);
          window.open(rootFolder, "_blank");

        }
        else {
          // match 2304.14575 inside the filename
          var rx = /[0-9][0-9][0-9][0-9]\.[0-9][0-9][0-9][0-9][0-9]/g;
          var matches = rx.exec(fileName);
          var arxivId = "";

          if (matches !== null && matches.length > 0) {
            arxivId = matches[0];
            console.log("arxiv id: " + arxivId);
          }
          else {
            console.log("cannot extract arxiv id");
          }

          var data = await thePdf.arrayBuffer();
          // console.log(data.byteLength);
          // console.log(data);

          var title = "";
          var author = "";

          await pdfjsLib.getDocument(data).promise.then(async doc => {
            // console.log(doc);

            doc.getMarkInfo().then(info => console.log("mark info: " + info));
            doc.getDownloadInfo().then(info => console.log("download info: " + info));
            doc.getFieldObjects().then(info => console.log("field objs: " + info));
            doc.getAttachments().then(info => console.log("attachments: " + info));
            doc.getOutline().then(info => console.log("outline: " + info));
            doc.getPage(1).then(firstPage => {
              console.log("first page: " + firstPage);
              firstPage.getTextContent({ normalizeWhitespace: true }).then(content => {
                console.log("content: " + content);
              });
            });

            var meta = doc.getMetadata();
            meta.then(metadata => {
              
              console.log(metadata);

              var info = metadata.info;
              console.log(info);

              var meta = metadata.metadata;
              console.log(meta);

              author = info.Author;
              title = info.Title;
              creator = info.Creator;
              subject = info.Subject;

              console.log("author: " + author);
              console.log("title: " + title);
              console.log("creator: " + creator);
              console.log("subject: " + subject);

              // sometimes the title contains an arxiv id
              // arXiv:2210.16580v1  [cs.DB]  29 Oct 2022
              if (title.startsWith("arXiv:")) {
                arxivId = title.split(":")[1].split(" ")[0].split("v")[0];
                console.log("extracted arxiv id from title: " + arxivId);
              }
              else if (title != "") {
                triggerStorkSearch(title);
              }

              doi = subject.split('doi:').slice(-1) + "";

              // we have an arxiv PDF
              if (arxivId != "") {
                getBib("https://arxiv.org/abs/" + arxivId);
              }
              // we have an HAL PDF
              else if (creator == "HAL") {

              }
              else if (doi !== null && isDoi(doi)) {

                console.log("We scraped a doi from the PDF: " + doi);
                getBib(doi);

              }
            });
          });
        }
      }

      function detectPaste(event) {
        // event.preventDefault();
        let paste = (event.clipboardData || window.clipboardData).getData("text");
        processBib(paste, "");
      };

      async function storkInit() {
        stork.initialize("{{ SITEURL }}/theme/js/stork-1.6/stork.wasm");
        options = {showScores: false};

        const deferred = async function() { //Async Function Expression
          stork.register("sitesearch", "{{ SITEURL }}/search-index.st", options);
          console.log("stork initialised");
        };

        deferred();
        
      }
    </script>

    <!-- <script src="https://files.stork-search.net/releases/v1.5.0/stork.js"></script> -->
    <script defer src="{{ SITEURL }}/theme/js/stork-1.6/stork.js" onload="storkInit()"></script>
    
  </body>
</html>
