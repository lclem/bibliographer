<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{% block title %}{{ SITENAME }}{% endblock %}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="{{ AUTHOR }}">
    <meta name="authors" content="{{ AUTHORS }}">
    <meta name="year" content="{{ YEAR }}">
    <meta name="bibfile" content="{{ BIBFILE }}">
    <meta name="pdffile" content="{{ PDFFILE }}">

    <!-- Le styles -->
    <link rel="stylesheet" href="{{ SITEURL }}/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="https://files.stork-search.net/basic.css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
      }
      main {

      }

      bib {
        display: none
      }

      /* .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;

        position: absolute;
        z-index: 1;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
      } */

      :root {
        --stork-border-color: hsl(0, 0%, 65%);
        --stork-background-color: hsla(0, 0%, 97%, 1);
        --stork-font-family: inherit;
        --stork-size-multiplier: 1;
        --stork-accent-color: hsl(210, 72%, 45%);

        --stork-input-width: 100%;
        --stork-input-border-radius: 8px;
        --stork-input-text-color: black;
        --stork-input-shadow: 1;

        --stork-results-width: 100%;
        --stork-results-border-radius: 4px;
        --stork-results-shadow: 1;
        --stork-results-hover-color: hsl(210, 65%, 75%);
        --stork-results-title-color: black;
        --stork-results-excerpt-color: black;
        --stork-results-highlight-color: rgb(245, 230, 26);
        --stork-results-border-color: var(--stork-border-color);
      }

      #add-button {
        display: none;
      }

      .stork-wrapper {
        position: relative;
        font-family: var(--stork-font-family);
        box-sizing: border-box;
        font-size: 1em * var(--stork-size-multiplier);
      }

      .stork-wrapper *,
      .stork-wrapper *:before,
      .stork-wrapper *:after {
        box-sizing: border-box;
      }

      .stork-input {
        width: var(--stork-input-width);
        height: 2.4em;
        font-size: 1em;
        padding: 0.4em 0.8em;
        position: relative;
        box-shadow: inset 0 0.1em 0.3em
          hsla(0, 0%, 0%, calc(var(--stork-input-shadow) * 0.25));
        border: 1px solid var(--stork-border-color);
        border-radius: var(--stork-input-border-radius);
        background-color: var(--stork-background-color);
        color: var(--stork-input-text-color);
        font-family: var(--stork-font-family);
      }

      .stork-input:focus {
        outline: none;
      }

      .stork-progress {
        position: absolute;
        display: block;
        content: "";
        bottom: 1px;
        background-color: var(--stork-accent-color);
        box-shadow: 0 0 8px var(--stork-accent-color);
        height: 1px;
        transition: width 0.25s ease, opacity 0.4s ease 0.4s;
      }

      .stork-output {
        position: absolute;
        width: var(--stork-results-width);
        margin-top: 0.5em;
        border-radius: var(--stork-results-border-radius);
        display: flex;
        flex-direction: column;
        z-index: 100;
        color: var(--stork-results-title-color);
        font-weight: 400;
        font-family: var(--stork-font-family);
      }

      .stork-attribution a:link,
      .stork-attribution a:visited {
        color: var(--stork-accent-color);
      }

      .stork-output-visible {
        border: 1px solid var(--stork-border-color);
        box-shadow: 0px 0px 2.2px
            rgba(0, 0, 0, calc(var(--stork-results-shadow) * 0.02)),
          0px 0px 5.3px rgba(0, 0, 0, calc(var(--stork-results-shadow) * 0.028)),
          0px 0px 10px rgba(0, 0, 0, calc(var(--stork-results-shadow) * 0.035)),
          0px 0px 17.9px rgba(0, 0, 0, calc(var(--stork-results-shadow) * 0.042)),
          0px 0px 33.4px rgba(0, 0, 0, calc(var(--stork-results-shadow) * 0.05)),
          0px 0px 80px rgba(0, 0, 0, calc(var(--stork-results-shadow) * 0.07));
        background: var(--stork-background-color);
      }

      .stork-message {
        width: 100%;
        padding: 0.5em 1em;
        color: var(--stork-results-title-color);
      }

      .stork-attribution {
        width: 100%;
        padding: 0.5em 1em;
        font-size: 0.8em;
        color: var(--stork-results-title-color);
      }

      .stork-results {
        margin: 0;
        padding: 0.25em 0;
        width: 100%;
        list-style-type: none;
        max-height: 25em;
        overflow-y: scroll;
        border-top: 1px solid var(--stork-border-color);
        border-bottom: 1px solid var(--stork-border-color);
        box-shadow: inset 0em 0.7em 0.7em -0.7em hsla(0, 0%, 0%, calc(var(
                    --stork-results-shadow
                  ) * 0.34)),
          inset 0em -0.7em 0.7em -0.7em
            hsl(0, 0%, 0%, calc(var(--stork-results-shadow) * 0.34));
      }

      .stork-result:not(:last-child) {
        border-bottom: 1px solid var(--stork-results-border-color);
      }

      .stork-result.selected {
        background: var(--stork-results-hover-color);
      }

      .stork-result a:link {
        padding: 1em;
        display: block;
        color: currentcolor;
        text-decoration: none;
      }

      .stork-result p {
        margin: 0;
      }

      .stork-title {
        font-weight: bold;
        font-size: 0.95em;
        margin: 0 0 0.75em 0;
        color: var(--stork-results-title-color);

        /* Flexbox container for the title and the score, when debugging */
        display: flex;
        justify-content: space-between;
      }

      .stork-excerpt {
        font-size: 0.8em;
        line-height: 1;
        margin: 0;
        color: var(--stork-results-excerpt-color);

        /* Flexbox container for the title and the score, when debugging */
        display: flex;
        justify-content: space-between;
      }

      .stork-excerpt:not(:last-of-type) {
        margin-bottom: 0.6em;
      }

      .stork-highlight {
        background-color: var(--stork-results-highlight-color);
        padding: 0 0.1em;
      }

      .stork-error {
        outline: 2px solid hsl(0, 89%, 46%);
      }

      .stork-close-button {
        position: absolute;
        bottom: 0;
        right: 0;
        margin: 0.3em 0.4em;
        height: 1.5em;
        width: 1.5em;
        padding: 0px;
        background: linear-gradient(
          to bottom,
          hsl(0, 0%, 85%) 0%,
          hsl(0, 0%, 75%) 100%
        );
        border: 1px solid hsla(0, 0%, 50%, 0.8);
        font-size: 1.1em;
        color: hsl(0, 0%, 45%);
        border-radius: 15%;
        line-height: 1;
      }

      .stork-close-button svg {
        width: 0.8em;
        position: relative;
        top: 1px;
      }

      .stork-close-button:hover {
        background: hsla(0, 0%, 70%);
        cursor: pointer;
      }

      .stork-close-button:active {
        background: hsla(0, 0%, 65%);
      }

      #drop-area {
        /* border: 2px dashed #ccc; */
        /* border-radius: 20px; */
        /* width: 480px; */
        /* font-family: sans-serif; */
        /* margin: 100px auto; */
        /* padding: 20px; */
      }
      #drop-area.highlight {
        /* border-color: purple; */
        background-color: aliceblue;
      }

      footer {
       display: block;
      }

      .pagination {
        height: 40px;
        margin: 20px 0px 50px 0;
      }
    </style>

    <link href="{{ SITEURL }}/theme/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/font-awesome.css" rel="stylesheet">
    <link href="{{ SITEURL }}/theme/css/pygments.css" rel="stylesheet">

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="{{ SITEURL }}/theme/images/favicon.ico">
    <link rel="apple-touch-icon" href="{{ SITEURL }}/theme/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="{{ SITEURL }}/theme/images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="{{ SITEURL }}/theme/images/apple-touch-icon-114x114.png">

    <link href="{{ SITEURL }}/{{ FEED }}" type="application/atom+xml" rel="alternate" title="{{ SITENAME }} ATOM Feed" />
    {% if FEED_RSS %}
    <link href="{{ SITEURL }}/{{ FEED_RSS }}" type="application/atom+xml" rel="alternate" title="{{ SITENAME }} RSS Feed" />
    {% endif %}

  </head>

  <body id="drop-area">
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="{{ SITEURL }}/index.html">{{ SITENAME }} {% if SITESUBTITLE %} <strong>{{ SITESUBTITLE }}</strong>{% endif %}</a>
          <div class="nav-collapse">
            <ul class="nav">
              {% for title, link in MENUITEMS %}
                <li><a href="{{ link }}">{{ title }}</a></li>
              {% endfor %}
              {% if DISPLAY_PAGES_ON_MENU %}
              {% for page in pages %}
                <li><a href="{{ SITEURL }}/{{ page.url }}">{{ page.title }}</a></li>
              {% endfor %}
              <li class="divider-vertical"></li>
              {% endif %}
              {% if DISPLAY_CATEGORIES_ON_MENU %}
              {% for cat, null in categories %}
                <li {% if cat == category %}class="active"{% endif %}>
                  <a href="{{ SITEURL }}/{{ cat.url }}">
						        <i class="icon-folder-open icon-large"></i>{{ cat }}
					        </a>
                </li>
              {% endfor %}
              {% endif %}
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
          <div class="stork-wrapper">
            <p>
              <input id="stork-input" class="stork-input" data-stork="sitesearch" placeholder="Search publication" onchange="updateSearch()"/>
              <button type="button" id="add-button" onclick="confirmBib()">Add reference</button>
            </p>
            <p>
              <div class="stork-output" data-stork="sitesearch-output"></div>
            </p>
          </div>
          {% block content %}
          {% endblock %}
          <p>
            <div class="small">
              Last Updated: {{ BUILD_TIME | strftime("%b %d, %Y, %H:%M:%S") }}
            </div>
          </p>      
        </div>
      </div>
  </div>
    <!-- Le javascript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="{{ SITEURL }}/theme/js/jquery-1.7.2.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bootstrap.min.js"></script>
    <script src="{{ SITEURL }}/theme/js/bibtexParse.js"></script>
    <script src="{{ SITEURL }}/theme/js/pdf.js"></script>
    <script>
      // https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/
			pdfjsLib.GlobalWorkerOptions.workerSrc =
				'{{ SITEURL }}/theme/js/pdf.worker.js';
		</script>
    <script src="https://files.stork-search.net/releases/v1.5.0/stork.js"></script>
    <script>
        options = {showScores: false};
        stork.register("sitesearch", "{{ SITEURL }}/search-index.st", options);
    </script>

    <script>
      let addButton = document.getElementById('add-button');
      var stork_input = document.getElementById('stork-input');
      let dropArea = document.getElementById('drop-area');
      let dt = [];

      stork_input.addEventListener("change", updateSearch, false);
      // stork_input.addEventListener("input", updateSearch, false);

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, preventDefaults, false)});
      ['dragenter', 'dragover'].forEach(eventName => {dropArea.addEventListener(eventName, highlight, false)});
      ['dragleave', 'drop'].forEach(eventName => {dropArea.addEventListener(eventName, unhighlight, false)});
      dropArea.addEventListener('drop', handleDrop, false)

      function preventDefaults (e) {
        e.preventDefault()
        e.stopPropagation()
      }

      function highlight(e) {
        dropArea.classList.add('highlight')
      }

      function unhighlight(e) {
        dropArea.classList.remove('highlight')
      }

      function handleDrop(e) {
        dt = e.dataTransfer;
        var len = dt.files.length;

        if (len != 1) {
          console.log("not supported: dropped files #" + len);
          return;
        }

        var theFile = dt.files[0];
        var fileName = theFile.name;

        if (fileName.endsWith(".bib")) {
          uploadBib(dt);
        }
        else if (fileName.endsWith(".pdf")) {
          uploadPdf(theFile);
        }
        else {
          console.log("unsupported format: " + fileName);
        }
      }

      const copyBib = async () => {
        try {
          let text = document.getElementById('bib').innerHTML;
          await navigator.clipboard.writeText(text);

          // var tooltip = document.getElementById("myTooltip");
          // tooltip.innerHTML = "copied to clipboard!";
          console.log('Content copied to clipboard');
        } catch (err) {
          // tooltip.innerHTML = "error: "+ err;
          console.error('Failed to copy: ', err);
        }
      }

      function triggerStorkSearch(str) {
        stork_input.value = str;
        stork_input.dispatchEvent(new Event('input', { bubbles: true }));
      }

      function outFunc() {
        var tooltip = document.getElementById("myTooltip");
        tooltip.innerHTML = "Copy to clipboard";
      }

      function confirmBib() {
        uploadBib(dt, true);
      }

      var bibFile;

      async function openGitHub(key, fileName, bibStr) {

        // TODO
        sanitisedKey = key.replace("/", "_");

        url = "https://github.com/lclem/bibliographer/new/main/library/entries/";
        url += sanitisedKey + "?filename=" + fileName + "&value=";
        url += encodeURIComponent(bibStr);

        window.open(url, "_blank");

        addButton.style.display = "none";

      }

      async function processBib(bibStr, fileName, force = false) {

        console.log("processBib: " + bibStr);

        try {
          bibJSONs = bibtexParse.toJSON(bibStr);

          for (bibJSON of bibJSONs) {
            console.log(bibJSON);

            key = bibJSON["citationKey"];
            console.log(key);

            tags = bibJSON["entryTags"];

            if ("title" in tags) {
              title = tags["title"];
            }
            else if ("Title" in tags) {
              title = tags["Title"];
            }
            else {
              title = ""
            }

            console.log(title);

            keySearchResults = stork.search("sitesearch", key);
            titleSearchResults = stork.search("sitesearch", title);
            let titleHit = false;

            if (titleSearchResults.total_hit_count > 0) {
              titleHit = titleSearchResults.results[0].score > 2000
            }

            if (!force && (keySearchResults.total_hit_count > 0 || titleHit)) {
              console.log("bib already exists");

              var str = "";

              if (keySearchResults.total_hit_count) {
                console.log(keySearchResults);
                str = key;
              }
              else {
                console.log(titleSearchResults);
                str = title;
              }

              triggerStorkSearch(str);
              addButton.style.display = "block";

            }
            else {

              // date-added    = "2018-12-22 10:50:04 +0100",
              var currentdate = new Date(); 
              var datetime =
                currentdate.getFullYear() + "-" +
                (currentdate.getMonth()+1) + "-" +
                currentdate.getDate() + " " +
                currentdate.getHours() + ":" +
                currentdate.getMinutes() + ":" +
                currentdate.getSeconds() +
                " +0100";

              bibJSON.entryTags["date-added"] = datetime;
              console.log(datetime);
              
              bibStr = bibtexParse.toBibtex([bibJSON], false);
              console.log(bibStr);

              openGitHub(key, fileName, bibStr);
            }
          }
        } catch (err) {
          console.error('Failed to parse bib: ', err);
        }
      }

      async function uploadBib(inp, force = false) {
          console.log(inp);

          if (force) {
          }
          else {
            bibFile = inp.files[0];
          }

          let fileName = bibFile.name;
          console.log("File name: " + fileName);

          var reader = new FileReader();
          reader.readAsText(bibFile, "UTF-8");
          reader.onload = function (evt) {
            bibStr = evt.target.result;
            processBib(bibStr, fileName, force)

          }
          reader.onerror = function (evt) {
            console.log("error reading file");
          }          
      }

      async function getBib(articleUrl) {

          // detect arxiv link
	        // TODO: handle also https://arxiv.org/abs/math/0703211
          if (articleUrl.startsWith("https://arxiv.org/abs/")) {

            var split = articleUrl.split("/");
            var id = split.slice(-1)[0];

            console.log("arxiv id: " + id);

            // https://arxiv.org/abs/2104.14624
            // https://arxiv.org/pdf/2104.14624.pdf
            // https://ui.adsabs.harvard.edu/abs/2021arXiv210414624G/exportcitation

            year = "20" + id.substring(0, 2);
            // theUrl = "https://ui.adsabs.harvard.edu/abs/" + year + "arXiv" + id.replace(".", "") + "G" + "/exportcitation"
            theUrl = "https://ui.adsabs.harvard.edu/abs/arXiv:" + id + "/exportcitation";

            if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
                xmlhttp=new XMLHttpRequest();
            }
            else {// code for IE6, IE5
                xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
            }
            xmlhttp.onreadystatechange = async function() {
              if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                let res = xmlhttp.responseText;
                // createDiv(xmlhttp.responseText);
                // console.log(res);

                var el = document.createElement('html');
                el.innerHTML = res;

                var els = el.getElementsByClassName('export-textarea');
                var bibStr = els[0].innerText;

                fileName = id + ".bib";
                processBib(bibStr, fileName);
              }
            }

            xmlhttp.open("GET", theUrl, false);
            xmlhttp.send();

            }
            // https://dl.acm.org/doi/10.1145/3087604.3087623
            else if (articleUrl.startsWith("https://dl.acm.org/doi/")) {

            }
            // https://epubs.siam.org/doi/abs/10.1137/S0097539793251219
            // https://epubs.siam.org/action/downloadCitation?format=bibtex&include=abs&direct=true&doi=10.1137/S0097539793251219&downloadFileName=siam_S0097539793251219
            else if (articleUrl.startsWith("https://epubs.siam.org/doi/abs/")) {

            }
      }

      async function updateSearch() {
          getBib(stork_input.value);
      }

      async function uploadPdf(thePdf) {

        console.log(thePdf);
        var fileName = thePdf.name;

        // match 2304.14575 inside the filename
        var rx = /[0-9][0-9][0-9][0-9]\.[0-9][0-9][0-9][0-9][0-9]/g;
        var matches = rx.exec(fileName);
        var arxivId = "";

        if (matches !== null && matches.length > 0) {
          arxivId = matches[0];
          console.log("arxiv id: " + arxivId);
        }
        else {
          console.log("cannot extract arxiv id");
        }

        var data = await thePdf.arrayBuffer();
        // console.log(data.byteLength);
        // console.log(data);

        var title = "";
        var author = "";

        await pdfjsLib.getDocument(data).promise.then(async doc => { 
          // console.log(doc);
          var meta = doc.getMetadata();
          meta.then(metadata => {
            
            console.log(metadata);

            var info = metadata.info;
            console.log(info);

            var meta = metadata.metadata;
            console.log(meta);

            author = info.Author;
            title = info.Title;

            console.log("author: " + author);
            console.log("title: " + title);

            if (title != "") {
              triggerStorkSearch(title);
            }
          });

        });

        // we have an arxiv PDF
        if (arxivId != "") {
          getBib("https://arxiv.org/abs/" + arxivId);
        }
        
      }
    </script>
  </body>
</html>